// Configuration for building
buildscript {
	repositories {
		// Bintray's repository - a fast Maven Central mirror & more
    	jcenter()    
    	mavenCentral()
 	}
	dependencies {	
		// Latest 1.x.x release
    	classpath 'com.google.cloud.tools:appengine-gradle-plugin:1.+'  
	}
}

plugins {
    // Apply the java-library plugin to add support for Java Library
    id 'java-library'
    // Create a web app to display the latest javadocs using Travis-CI with Google Cloud
    id 'war'
}
apply plugin: 'com.google.cloud.tools.appengine'

// repositories for Jar's you access in your code
repositories {
    // Use jcenter for resolving dependencies.
    // You can declare any Maven/Ivy/file repository here.
    jcenter()
   	mavenCentral()
}



dependencies {
    // This dependency is exported to consumers, that is to say found on their compile classpath.
    api 'org.apache.commons:commons-math3:3.6.1'

    // This dependency is used internally, and not exposed to consumers on their own compile classpath.
    implementation 'com.google.guava:guava:28.0-jre'

    // Use JUnit test framework
    testImplementation 'junit:junit:4.12'
    
    compile 'com.google.appengine:appengine-api-1.0-sdk:+'  // Latest App Engine Api's
	providedCompile 'javax.servlet:javax.servlet-api:3.1.0'
	compile 'jstl:jstl:1.2'

	// Add your dependencies here.
	// compile 'com.google.cloud:google-cloud:+'   
	// Latest Cloud API's http://googlecloudplatform.github.io/google-cloud-java

	testCompile 'junit:junit:4.12'
	testCompile 'com.google.truth:truth:0.33'
	testCompile 'org.mockito:mockito-all:1.10.19'

	testCompile 'com.google.appengine:appengine-testing:+'
	testCompile 'com.google.appengine:appengine-api-stubs:+'
	testCompile 'com.google.appengine:appengine-tools-sdk:+' 
}

// Always run unit tests
appengineDeploy.dependsOn test
appengineStage.dependsOn test

// App Engine tasks configuration
appengine {
	// deploy configuration
	deploy {   

	}
}

test {
	testLogging {
		//-XX:MaxJavaStackTraceDepth
		//events "passed", "skipped", "failed", "standardOut", "standardError"
		exceptionFormat = "full"
		showExceptions = true
	}
	
	useJUnit()
	testLogging.showStandardStreams = true
	beforeTest { descriptor ->
		logger.lifecycle("test: " + descriptor + "  Running")
		}
	onOutput { descriptor, event ->
		logger.lifecycle("test: " + descriptor + ": " + event.message )
	}
	afterTest { descriptor, result ->
		logger.lifecycle("test: " + descriptor + ": " + result )
	}
	
	/* This will cause tests to wait for a remote debugger attached on port 5005
	* Eclipse: 
	* 1. Go to Debug Configurations
	* 2. Make a new Remote Java Application
	* 3. Set Host to localhost and Port to 5005
	* 4. Enable "Allow termination of remote VM"
	* 5. Switch to Source tab
	* 6. Click Add button
	* 7. Select File System Directory 
	* 8. Browse for the folder with all the source files
	* 9. Save all changes
	* 10. Set breakpoints
	* 11. Run gradle build or gradle test to initiate tests
	* 12. Gradle will pause til a connection is recieved
	* 13. Run your Remote Java Application
	* 14. Enjoy Debugging!
	*/
	//debug true
}

/* Throw javadocs into main/webapp and use it as a static application,
* ensure that the directory exists, possibly remove original directory 
* as well. 
*
* TODO: add a server that serves the files as-is, static content
* TODO: deploy to google cloud
* TODO: add proxy map and serve root from adrianhernandez.dev/graphitePencilJavaDocs
*/
javadoc {
	destinationDir = file("$projectDir/src/main/webapp")
	includes = ["*.js","*.html","*.css","*.png"]
}

sourceCompatibility = 1.8     // App Engine Flexible uses Java 8
targetCompatibility = 1.8     // App Engine Flexible uses Java 8